# ADR-003: JSONL Parser Architecture

**Status:** Accepted  
**Datum:** 2025-10-15  
**Entscheider:** Migration Team  
**Kontext:** VB.NET → Go Migration für EVE SDE Database Builder  
**Abhängig von:** ADR-001 (SQLite-Only), ADR-002 (Database Layer)

---

## Kontext & Problem

### EVE SDE Datenformat

**Aktuell (JSONL):**

- 50+ Dateien (z.B. `types.jsonl`, `blueprints.jsonl`, `dogmaAttributes.jsonl`)
- Format: JSON Lines (ein JSON-Objekt pro Zeile)
- Größe: ~500 MB komprimiert, ~1.5 GB unkomprimiert
- Schema: Variiert pro Datei, teilweise verschachtelt

**Beispiel `types.jsonl`:**

```jsonl
{"typeID": 34, "groupID": 18, "typeName": {"de": "Tritanium", "en": "Tritanium"}, "mass": 0.01, "volume": 0.01, "published": true}
{"typeID": 35, "groupID": 18, "typeName": {"de": "Pyerite", "en": "Pyerite"}, "mass": 0.01, "volume": 0.01, "published": true}
```

### VB.NET Status Quo (YAML-Parser)

**Problem:** VB.NET Tool nutzt **YAML** (nicht JSONL), hat aber 70+ Parser-Klassen:

```vb
' YAMLtypes.vb (~460 Zeilen)
Public Class YAMLtypes
    Private _typeID As Integer
    Private _groupID As Integer
    Private _typeName As Dictionary(Of String, String)
    Private _mass As Double
    ' ... 20+ weitere Properties
    
    Public Sub ParseYAML(yaml As String)
        ' YamlDotNet Parsing...
    End Sub
End Class
```

**Charakteristik:**

- Hand-written für jede Tabelle
- Reflection-basiert (YamlDotNet)
- Typsicher (VB.NET Properties)

### Herausforderung

**70+ Parser migrieren:**

1. **Hand-written Go Structs?** → Wartungsaufwand hoch
2. **Code Generation?** → Schema-Quelle unklar (kein offizielles JSON Schema)
3. **Generic Parser?** → Type Safety verloren
4. **Hybrid?** → Kritische Parser typsicher, Rest generisch

---

## Entscheidung

Wir verwenden **Full Code Generation** für alle 50+ JSONL-Tabellen via **RIFT SDE Schema**.

**Ansatz:** RIFT Schema-Scraping + `quicktype` Code-Generation für konsistente, typsichere Structs.

### Architektur

```go
// internal/parser/generated/types.go
// Code generated by quicktype + add-tomap-methods.go. DO NOT EDIT.
package generated

import (
    "encoding/json"
)

// TypeRow - Generierter Struct für types.jsonl (via RIFT Schema)
type TypeRow struct {
    TypeID      int                       `json:"typeID"`
    GroupID     int                       `json:"groupID"`
    TypeName    map[string]string         `json:"typeName"`
    Description map[string]string         `json:"description,omitempty"`
    Mass        float64                   `json:"mass,omitempty"`
    Volume      float64                   `json:"volume,omitempty"`
    Capacity    float64                   `json:"capacity,omitempty"`
    Published   bool                      `json:"published"`
    // ... weitere Felder (vollständig via Code-Gen)
}

// ParseJSONL - Generischer JSONL-Parser
func ParseJSONL[T any](r io.Reader) ([]T, error) {
    var results []T
    scanner := bufio.NewScanner(r)
    
    for scanner.Scan() {
        var item T
        if err := json.Unmarshal(scanner.Bytes(), &item); err != nil {
            return nil, fmt.Errorf("parse error: %w", err)
        }
        results = append(results, item)
    }
    
    if err := scanner.Err(); err != nil {
        return nil, err
    }
    
    return results, nil
}

// Verwendung
func ImportTypes(file io.Reader, db *database.DB) error {
    types, err := ParseJSONL[TypeRow](file)
    if err != nil {
        return err
    }
    
    return db.BatchInsert("invTypes", toMapSlice(types))
}
```

### Begründung

- ✅ **Konsistenz:** Ein Pattern für alle 50+ Tabellen (kein Hybrid-Chaos)
- ✅ **Type Safety:** Überall Compile-Zeit-Checks, keine Runtime-Errors
- ✅ **Wartbarkeit:** Schema-Updates → Re-Gen statt manuelles Patching
- ✅ **RIFT Schema verfügbar:** [sde.riftforeve.online](https://sde.riftforeve.online/) liefert vollständige Doku + Code-Snippets
- ✅ **IDE Support:** Autocomplete für alle Felder in allen Tabellen
- ✅ **Sauberer:** Keine Entscheidung "Typed vs. Generic" pro Tabelle

**Warum JETZT (v1.0) statt später?**

- ✅ **Einmalige Upfront-Arbeit:** 50+ Structs generieren + reviewen (1-2 Tage)
- ✅ **Langfristig weniger Aufwand:** Keine Hybrid-Code-Pfade, keine spätere Migration
- ✅ **RIFT Tool-Chain:** `quicktype` ist bewährt, RIFT nutzt es bereits
- ✅ **Refactoring-Sicherheit:** Compiler findet Fehler, nicht Runtime

---

## Konsequenzen

### Positive Konsequenzen

1. **Full Type Safety:** Alle 50+ Tabellen mit Compile-Zeit-Checks
2. **Konsistenz:** Ein einheitliches Pattern für alle Parser
3. **Automatisierung:** Schema-Updates via Re-Gen statt manueller Anpassung
4. **IDE Support:** Autocomplete + Refactoring für alle SDE-Daten
5. **Performance:** `encoding/json` mit Typed Structs (kein Reflection)
6. **Wartbarkeit:** Generierter Code ist konsistent, kein Duplicate Logic

### Negative Konsequenzen

1. **Initial-Aufwand:** 50+ generierte Files reviewen + anpassen (DB-Mapping)
2. **Code-Volume:** Mehr generierter Code im Repo (aber konsistent)
3. **Build-Komplexität:** Code-Gen-Step in Build-Pipeline integrieren
4. **Schema Drift:** SDE-Updates erfordern Re-Gen (aber automatisiert)

### Mitigationen

| Konsequenz | Mitigation |
|------------|------------|
| Initial-Aufwand | Makefile Target `make generate-parsers` automatisiert Workflow |
| Code-Volume | Generierte Files in `internal/parser/generated/` (klare Trennung) |
| Build-Komplexität | CI-Pipeline prüft ob generierter Code aktuell ist |
| Schema Drift | `make update-schemas` + Re-Gen bei SDE-Updates (versioniert) |

---

## Alternativen (erwogen & verworfen)

### Alternative 1: Full Code Generation (RIFT Schema → Go)

**Tools:** `quicktype` (RIFT nutzt das bereits), Custom Scraper

**Pro:**

- ✅ Alle 50+ Tabellen automatisch
- ✅ Schema verfügbar: [RIFT SDE](https://sde.riftforeve.online/schema/types/) dokumentiert alle Fields + Ranges
- ✅ RIFT liefert bereits Go-Code-Snippets (via quicktype)

**Contra:**

- ⚠️ 50+ Files generieren = hoher Review-Aufwand für v1.0
- ⚠️ RIFT-Code braucht Anpassung (DB-Mapping, `ToMap()` Methoden fehlen)
- ⚠️ Schema-Updates erfordern Re-Generation (Wartungsaufwand)

**Entscheidung:** ✅ **Accepted für v1.0** – RIFT Schema macht Code-Gen machbar und sauber

### Alternative 2: Pure Generic Map (`map[string]interface{}`)

**Pro:**

- ✅ Null Boilerplate
- ✅ Schema-unabhängig
- ✅ 1 Parser für alle Tabellen

**Contra:**

- ❌ Keine Type Safety
- ❌ Runtime-Fehler bei Typo (`typeID` vs `TypeID`)
- ❌ Schlechte IDE-Unterstützung

**Entscheidung:** ❌ Verworfen (keine Type Safety, fehleranfällig)

### Alternative 3: Reflection-basiert (wie VB.NET YamlDotNet)

**Pro:**

- ✅ Ähnlich zu VB.NET
- ✅ Flexible Schema-Mappings

**Contra:**

- ❌ Performance-Overhead
- ❌ Komplexer als direkte JSON-Unmarshalling
- ❌ Go Reflection ist weniger ergonomisch als .NET

**Entscheidung:** Verworfen (JSON stdlib ist ausreichend)

### Alternative 4: YAML beibehalten (gopkg.in/yaml.v3)

**Pro:**

- ✅ Näher am VB.NET-Code
- ✅ YAML-Parsing-Erfahrung übertragbar

**Contra:**

- ❌ CCP liefert **JSONL** (nicht YAML)
- ❌ Externe Dependency (yaml.v3)
- ❌ YAML-Parsing langsamer als JSON
- ❌ Konvertierung JSONL→YAML wäre extra Schritt

**Entscheidung:** Verworfen (unnötige Komplexität)

---

## Implementierungsdetails

### 1. Code-Generation Workflow

**Makefile Target:**

```makefile
# Makefile
.PHONY: generate-parsers
generate-parsers:
	@echo "Scraping RIFT SDE Schemas..."
	go run tools/scrape-rift-schemas.go --output schemas/
	@echo "Generating Go Structs..."
	quicktype --src schemas/*.json --lang go --out internal/parser/generated/ \
		--package generated --just-types
	@echo "Adding DB-Mapping Methods..."
	go run tools/add-tomap-methods.go internal/parser/generated/*.go
	@echo "Formatting..."
	go fmt internal/parser/generated/
```

**Generierte Struktur:**

```
internal/parser/
├── generated/          # Auto-generiert (nicht manuell editieren)
│   ├── types.go       # TypeRow struct
│   ├── blueprints.go  # BlueprintRow struct
│   ├── dogma.go       # DogmaAttributeRow, DogmaEffectRow
│   └── ...            # 50+ weitere Files
├── jsonl.go           # Generic ParseJSONL[T] Funcs
└── mapper.go          # ToMap() Interface + Helpers
```

### 2. Generierter Code (Beispiel)

```go
// internal/parser/generated/types.go
// Code generated by quicktype + add-tomap-methods.go. DO NOT EDIT.
package generated

import "encoding/json"

// TypeRow repräsentiert eine Zeile aus types.jsonl
type TypeRow struct {
    Key              int                `json:"_key"`
    BasePrice        *float64           `json:"basePrice,omitempty"`
    Capacity         *float64           `json:"capacity,omitempty"`
    Description      *Description       `json:"description,omitempty"`
    FactionID        *int               `json:"factionID,omitempty"`
    GraphicID        *int               `json:"graphicID,omitempty"`
    GroupID          int                `json:"groupID"`
    IconID           *int               `json:"iconID,omitempty"`
    MarketGroupID    *int               `json:"marketGroupID,omitempty"`
    Mass             *float64           `json:"mass,omitempty"`
    MetaGroupID      *int               `json:"metaGroupID,omitempty"`
    Name             Name               `json:"name"`
    PortionSize      int                `json:"portionSize"`
    Published        bool               `json:"published"`
    Radius           *float64           `json:"radius,omitempty"`
    Volume           *float64           `json:"volume,omitempty"`
}

type Description struct {
    De *string `json:"de,omitempty"`
    En string  `json:"en"`
    Es *string `json:"es,omitempty"`
    Fr *string `json:"fr,omitempty"`
    Ja *string `json:"ja,omitempty"`
    Ko *string `json:"ko,omitempty"`
    Ru *string `json:"ru,omitempty"`
    Zh *string `json:"zh,omitempty"`
}

type Name struct {
    De *string `json:"de,omitempty"`
    En string  `json:"en"`
    // ... weitere Sprachen
}

// ToMap konvertiert Struct zu map[string]interface{} für DB-Insert
// (Generiert via add-tomap-methods.go)
func (t TypeRow) ToMap() map[string]interface{} {
    m := map[string]interface{}{
        "typeID":      t.Key,
        "groupID":     t.GroupID,
        "typeName_en": t.Name.En,
        "portionSize": t.PortionSize,
        "published":   t.Published,
    }
    
    // Optionale Felder nur wenn gesetzt
    if t.Mass != nil {
        m["mass"] = *t.Mass
    }
    if t.Volume != nil {
        m["volume"] = *t.Volume
    }
    if t.Description != nil {
        m["description_en"] = t.Description.En
    }
    
    return m
}
```

### 3. Generic JSONL Parser (Wiederverwendbar)

```go
// internal/parser/jsonl.go
package parser

import (
    "bufio"
    "encoding/json"
    "fmt"
    "io"
)

// ParseJSONL liest JSONL und unmarshalled zu Typ T
func ParseJSONL[T any](r io.Reader) ([]T, error) {
    var results []T
    scanner := bufio.NewScanner(r)
    scanner.Buffer(make([]byte, 1024*1024), 10*1024*1024) // 10MB Buffer für große Zeilen
    
    lineNum := 0
    for scanner.Scan() {
        lineNum++
        var item T
        if err := json.Unmarshal(scanner.Bytes(), &item); err != nil {
            return nil, fmt.Errorf("line %d: %w", lineNum, err)
        }
        results = append(results, item)
    }
    
    if err := scanner.Err(); err != nil {
        return nil, fmt.Errorf("scanner error: %w", err)
    }
    
    return results, nil
}

// ParseJSONLStream - Streaming-Variante für große Files
func ParseJSONLStream[T any](r io.Reader, callback func(T) error) error {
    scanner := bufio.NewScanner(r)
    scanner.Buffer(make([]byte, 1024*1024), 10*1024*1024)
    
    lineNum := 0
    for scanner.Scan() {
        lineNum++
        var item T
        if err := json.Unmarshal(scanner.Bytes(), &item); err != nil {
            return fmt.Errorf("line %d: %w", lineNum, err)
        }
        
        if err := callback(item); err != nil {
            return fmt.Errorf("callback line %d: %w", lineNum, err)
        }
    }
    
    return scanner.Err()
}
```

### 4. Import-Workflow (End-to-End)

```go
// cmd/esdedb/import.go
package main

import (
    "compress/gzip"
    "os"
    
    "github.com/Sternrassler/EVE-SDE-Database-Builder/internal/database"
    "github.com/Sternrassler/EVE-SDE-Database-Builder/internal/parser"
)

func ImportTypes(dbPath, jsonlPath string) error {
    db, err := database.NewDB(dbPath)
    if err != nil {
        return err
    }
    defer db.Close()
    
    // JSONL-File öffnen (ggf. gzip-komprimiert)
    file, err := os.Open(jsonlPath)
    if err != nil {
        return err
    }
    defer file.Close()
    
    reader := io.Reader(file)
    if strings.HasSuffix(jsonlPath, ".gz") {
        gzReader, _ := gzip.NewReader(file)
        defer gzReader.Close()
        reader = gzReader
    }
    
    // Streaming-Import (Memory-effizient)
    return parser.ParseJSONLStream[parser.TypeRow](reader, func(t parser.TypeRow) error {
        return db.Insert("invTypes", t.ToMap())
    })
}
```

### 5. Testing-Strategie

```go
// internal/parser/types_test.go
package parser_test

import (
    "strings"
    "testing"
    
    "github.com/Sternrassler/EVE-SDE-Database-Builder/internal/parser"
    "github.com/stretchr/testify/assert"
)

func TestParseTypesJSONL(t *testing.T) {
    jsonl := `{"typeID":34,"groupID":18,"typeName":{"en":"Tritanium"},"mass":0.01,"published":true}
{"typeID":35,"groupID":18,"typeName":{"en":"Pyerite"},"mass":0.01,"published":true}`
    
    types, err := parser.ParseJSONL[parser.TypeRow](strings.NewReader(jsonl))
    
    assert.NoError(t, err)
    assert.Len(t, types, 2)
    assert.Equal(t, 34, types[0].TypeID)
    assert.Equal(t, "Tritanium", types[0].TypeName["en"])
}

func TestParseTypesJSONL_InvalidJSON(t *testing.T) {
    jsonl := `{"typeID":34,"invalid json`
    
    _, err := parser.ParseJSONL[parser.TypeRow](strings.NewReader(jsonl))
    
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "line 1")
}
```

### 6. Schema-Validierung (Optional)

```go
// internal/parser/validator.go
package parser

import "fmt"

// ValidateTypeRow prüft Business-Regeln
func (t TypeRow) Validate() error {
    if t.TypeID <= 0 {
        return fmt.Errorf("invalid typeID: %d", t.TypeID)
    }
    if t.GroupID <= 0 {
        return fmt.Errorf("invalid groupID: %d", t.GroupID)
    }
    if len(t.TypeName) == 0 {
        return fmt.Errorf("typeName is empty")
    }
    return nil
}
```

---

## Migration von VB.NET

### Code-Vergleich

**VB.NET (YAML):**

```vb
' YAMLtypes.vb
Public Class YAMLtypes
    Private _typeID As Integer
    Private _typeName As Dictionary(Of String, String)
    
    Public Sub ParseYAML(yaml As String)
        Dim deserializer = New DeserializerBuilder().Build()
        Dim yamlObject = deserializer.Deserialize(Of Dictionary(Of Object, Object))(yaml)
        
        _typeID = CInt(yamlObject("typeID"))
        _typeName = CType(yamlObject("name"), Dictionary(Of String, String))
    End Sub
End Class
```

**Go (JSONL):**

```go
// internal/parser/types.go
type TypeRow struct {
    TypeID   int               `json:"typeID"`
    TypeName map[string]string `json:"typeName"`
}

// Parsing ist automatisch via encoding/json
types, _ := ParseJSONL[TypeRow](file)
```

**Unterschiede:**

- ✅ Go: Deklarativ (Struct Tags), VB.NET: Imperativ (Deserializer)
- ✅ Go: Stdlib (`encoding/json`), VB.NET: External (YamlDotNet)
- ✅ Go: Generics ermöglichen Wiederverwendung

---

## Performance-Erwartungen

### Benchmark-Ziele (types.jsonl ~500k Zeilen)

| Operation | VB.NET (YAML) | Go (JSONL) | Verbesserung |
|-----------|---------------|------------|--------------|
| Parse Full File | ~8s | ~2s | 4x |
| Memory Peak | ~800 MB | ~200 MB | 4x |
| Streaming Parse | N/A | ~3s | - |

**Begründung:** JSON schneller als YAML, Go Memory-Effizienz

---

## Compliance & Governance

### Normative Anforderungen

- ✅ **MUST:** Tests für alle Parser → Unit + Integration Tests
- ✅ **SHOULD:** Performance-Optimierung → Streaming für große Files
- ✅ **MAY:** Code Generation → v2.0 Evaluation

### ADR-Abhängigkeiten

- **ADR-001:** SQLite-Only → Vereinfacht DB-Mapping
- **ADR-002:** sqlx → `ToMap()` passt zu `NamedExec`

---

## Referenzen

**Go Standard Library:**

- [encoding/json](https://pkg.go.dev/encoding/json)
- [bufio.Scanner](https://pkg.go.dev/bufio#Scanner)

**EVE SDE:**

- [RIFT SDE Schema](https://sde.riftforeve.online/) - **Vollständige Schema-Dokumentation** (alle 50+ Tabellen)
- [RIFT Schema: types.jsonl](https://sde.riftforeve.online/schema/types/) - Beispiel mit Go-Code-Snippets
- [RIFT Schema: blueprints.jsonl](https://sde.riftforeve.online/schema/blueprints/) - Komplexes Beispiel
- [CCP SDE Downloads](https://developers.eveonline.com/static-data) - Originale JSONL-Files

**Code Generation Tools (v1.0):**

- [quicktype](https://quicktype.io/) - JSON → Go Structs (RIFT nutzt dies bereits)
- [gojsonschema](https://github.com/xeipuuv/gojsonschema) - Schema-Validierung (optional)
- [gjson](https://github.com/tidwall/gjson) - JSON Path Queries (Schema-Extraktion, optional)

**Code-Generation Workflow (v1.0):**

```bash
# Option A: RIFT Schema scrapen (automatisch aus sde.riftforeve.online)
go run tools/scrape-rift-schemas.go --output ./schemas/

# Option B: Direkt aus RIFT Code-Snippets extrahieren
curl https://sde.riftforeve.online/schema/types/ | \
  grep -A 10000 '```go' | \
  sed '1d;$d' > internal/parser/generated/types.go

# Structs generieren (alle 50+ Tabellen für v1.0)
quicktype --src schemas/*.json --lang go --out internal/parser/generated/

# DB-Mapping Methods hinzufügen
go run tools/add-tomap-methods.go internal/parser/generated/*.go
```

**RIFT liefert bereits Go-Code** (via quicktype), braucht nur Anpassung für DB-Mapping (`ToMap()` Methoden via `add-tomap-methods.go`).

---

## Änderungshistorie

| Datum | Version | Änderung | Autor |
|-------|---------|----------|-------|
| 2025-10-15 | 0.1.0 | Initial Draft | AI Copilot |
| 2025-10-15 | 1.0.0 | Status → Accepted (Full Code-Gen für v1.0) | Migration Team |

---

**Nächste Schritte:**

1. ✅ ~~Review durch Team~~ (Accepted)
2. Tool: `scrape-rift-schemas.go` implementieren (RIFT HTML → JSON Schema)
3. Tool: `add-tomap-methods.go` implementieren (Post-Processing)
4. `make generate-parsers` ausführen → 50+ Structs generieren
5. Review: Generierte Structs + ToMap() prüfen
6. Prototyp: `types.jsonl` → SQLite (End-to-End mit Generated Struct)
7. ✅ ~~Bei Erfolg: Status → `Accepted`~~
