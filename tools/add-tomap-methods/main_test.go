// tools/add-tomap-methods_test.go
// Tests for ToMap method post-processing tool
package main

import (
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"testing"
)

// TestExtractJSONTag tests JSON tag extraction
func TestExtractJSONTag(t *testing.T) {
	tests := []struct {
		name     string
		tag      string
		expected string
	}{
		{
			name:     "Simple JSON tag",
			tag:      "`json:\"typeID\"`",
			expected: "typeID",
		},
		{
			name:     "JSON tag with omitempty",
			tag:      "`json:\"mass,omitempty\"`",
			expected: "mass",
		},
		{
			name:     "JSON tag with dash (skip)",
			tag:      "`json:\"-\"`",
			expected: "-",
		},
		{
			name:     "Multiple tags",
			tag:      "`json:\"name\" db:\"name\" validate:\"required\"`",
			expected: "name",
		},
		{
			name:     "No JSON tag",
			tag:      "`db:\"name\"`",
			expected: "",
		},
		{
			name:     "Empty tag",
			tag:      "``",
			expected: "",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := extractJSONTag(tt.tag)
			if result != tt.expected {
				t.Errorf("Expected %q, got %q", tt.expected, result)
			}
		})
	}
}

// TestIsBuiltinType tests builtin type detection
func TestIsBuiltinType(t *testing.T) {
	tests := []struct {
		name     string
		typeName string
		expected bool
	}{
		{name: "int", typeName: "int", expected: true},
		{name: "string", typeName: "string", expected: true},
		{name: "bool", typeName: "bool", expected: true},
		{name: "float64", typeName: "float64", expected: true},
		{name: "Custom type", typeName: "TypeRow", expected: false},
		{name: "time.Time", typeName: "Time", expected: false},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := isBuiltinType(tt.typeName)
			if result != tt.expected {
				t.Errorf("Expected %v, got %v", tt.expected, result)
			}
		})
	}
}

// TestExtractStructs tests struct extraction from Go source
func TestExtractStructs(t *testing.T) {
	source := `
package test

// Code generated by quicktype. DO NOT EDIT.

type TypeRow struct {
	TypeID   int    ` + "`json:\"typeID\"`" + `
	TypeName string ` + "`json:\"typeName\"`" + `
	Mass     *float64 ` + "`json:\"mass,omitempty\"`" + `
	internal string  // unexported field
}

type GroupRow struct {
	GroupID int ` + "`json:\"groupID\"`" + `
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", source, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse source: %v", err)
	}

	structs := extractStructs(file)

	// Check we found 2 structs
	if len(structs) != 2 {
		t.Fatalf("Expected 2 structs, got %d", len(structs))
	}

	// Check TypeRow
	typeRow, ok := structs["TypeRow"]
	if !ok {
		t.Fatal("TypeRow not found")
	}

	// Should have 3 exported fields (internal is unexported)
	if len(typeRow) != 3 {
		t.Errorf("Expected 3 fields in TypeRow, got %d", len(typeRow))
	}

	// Check field details
	for _, field := range typeRow {
		switch field.Name {
		case "TypeID":
			if field.JSONTag != "typeID" {
				t.Errorf("Expected JSON tag 'typeID', got '%s'", field.JSONTag)
			}
			if field.IsPtr {
				t.Error("TypeID should not be a pointer")
			}
		case "Mass":
			if field.JSONTag != "mass" {
				t.Errorf("Expected JSON tag 'mass', got '%s'", field.JSONTag)
			}
			if !field.IsPtr {
				t.Error("Mass should be a pointer")
			}
		}
	}

	// Check GroupRow
	groupRow, ok := structs["GroupRow"]
	if !ok {
		t.Fatal("GroupRow not found")
	}

	if len(groupRow) != 1 {
		t.Errorf("Expected 1 field in GroupRow, got %d", len(groupRow))
	}
}

// TestGenerateToMapMethod tests ToMap method generation
func TestGenerateToMapMethod(t *testing.T) {
	fields := []FieldInfo{
		{Name: "TypeID", JSONTag: "typeID", Type: "int", IsPtr: false},
		{Name: "TypeName", JSONTag: "typeName", Type: "string", IsPtr: false},
		{Name: "Mass", JSONTag: "mass", Type: "*float64", IsPtr: true},
	}

	method := generateToMapMethod("TypeRow", fields)

	// Check method signature
	if !strings.Contains(method, "func (t *TypeRow) ToMap()") {
		t.Error("Method signature not found")
	}

	// Check return type
	if !strings.Contains(method, "map[string]interface{}") {
		t.Error("Return type not correct")
	}

	// Check field mappings
	expectedMappings := []string{
		`m["typeID"] = t.TypeID`,
		`m["typeName"] = t.TypeName`,
		`if t.Mass != nil`,
		`m["mass"] = *t.Mass`,
	}

	for _, expected := range expectedMappings {
		if !strings.Contains(method, expected) {
			t.Errorf("Expected mapping not found: %s", expected)
		}
	}
}

// TestGenerateToMapMethod_NestedStruct tests nested struct handling
func TestGenerateToMapMethod_NestedStruct(t *testing.T) {
	fields := []FieldInfo{
		{Name: "Name", JSONTag: "name", Type: "Name", IsStruct: true},
		{Name: "Description", JSONTag: "description", Type: "*Description", IsPtr: true, IsStruct: true},
	}

	method := generateToMapMethod("TypeRow", fields)

	// Check nested struct handling includes ToMap check
	if !strings.Contains(method, "if toMapper, ok := interface{}") {
		t.Error("Nested struct ToMap check not found")
	}

	// Check comment for nested structs
	if !strings.Contains(method, "// Nested struct field") {
		t.Error("Nested struct comment not found")
	}
}

// TestExtractExistingToMapMethods tests detection of existing ToMap methods
func TestExtractExistingToMapMethods(t *testing.T) {
	source := `
package test

type TypeRow struct {
	TypeID int
}

func (t *TypeRow) ToMap() map[string]interface{} {
	return map[string]interface{}{"typeID": t.TypeID}
}

type GroupRow struct {
	GroupID int
}
`

	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "test.go", source, parser.ParseComments)
	if err != nil {
		t.Fatalf("Failed to parse source: %v", err)
	}

	methods := extractExistingToMapMethods(file)

	// Should find ToMap for TypeRow but not GroupRow
	if !methods["TypeRow"] {
		t.Error("Expected to find ToMap method for TypeRow")
	}

	if methods["GroupRow"] {
		t.Error("Should not find ToMap method for GroupRow")
	}

	if len(methods) != 1 {
		t.Errorf("Expected 1 method, found %d", len(methods))
	}
}

// TestProcessFile_Integration tests full file processing
func TestProcessFile_Integration(t *testing.T) {
	// Create temporary test file
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "types.go")

	source := `package generated

// Code generated by quicktype. DO NOT EDIT.

type TypeRow struct {
	TypeID   int      ` + "`json:\"typeID\"`" + `
	TypeName string   ` + "`json:\"typeName\"`" + `
	Mass     *float64 ` + "`json:\"mass,omitempty\"`" + `
}
`

	err := os.WriteFile(testFile, []byte(source), 0644)
	if err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	// Process the file
	cfg := &Config{
		InputFiles:  []string{testFile},
		DryRun:      false,
		Verbose:     false,
		ForceUpdate: false,
	}

	err = processFile(testFile, cfg)
	if err != nil {
		t.Fatalf("Failed to process file: %v", err)
	}

	// Read the result
	result, err := os.ReadFile(testFile)
	if err != nil {
		t.Fatalf("Failed to read result: %v", err)
	}

	resultStr := string(result)

	// Verify ToMap method was added
	if !strings.Contains(resultStr, "func (t *TypeRow) ToMap()") {
		t.Error("ToMap method not added")
	}

	// Verify original struct is preserved
	if !strings.Contains(resultStr, "type TypeRow struct") {
		t.Error("Original struct not preserved")
	}

	// Verify the code still compiles
	fset := token.NewFileSet()
	_, err = parser.ParseFile(fset, testFile, result, parser.ParseComments)
	if err != nil {
		t.Errorf("Generated code does not parse: %v", err)
	}
}

// TestProcessFile_AlreadyHasToMap tests skipping files with existing ToMap
func TestProcessFile_AlreadyHasToMap(t *testing.T) {
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "types.go")

	source := `package generated

// Code generated by quicktype. DO NOT EDIT.

type TypeRow struct {
	TypeID int ` + "`json:\"typeID\"`" + `
}

func (t *TypeRow) ToMap() map[string]interface{} {
	return map[string]interface{}{"typeID": t.TypeID}
}
`

	err := os.WriteFile(testFile, []byte(source), 0644)
	if err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	originalContent, _ := os.ReadFile(testFile)

	// Process the file
	cfg := &Config{
		InputFiles:  []string{testFile},
		DryRun:      false,
		Verbose:     false,
		ForceUpdate: false,
	}

	err = processFile(testFile, cfg)
	if err != nil {
		t.Fatalf("Failed to process file: %v", err)
	}

	// Read the result
	result, err := os.ReadFile(testFile)
	if err != nil {
		t.Fatalf("Failed to read result: %v", err)
	}

	// Content should be unchanged (file was skipped)
	// Note: formatting might change, so parse both and compare
	fset1 := token.NewFileSet()
	file1, _ := parser.ParseFile(fset1, "", originalContent, 0)

	fset2 := token.NewFileSet()
	file2, _ := parser.ParseFile(fset2, "", result, 0)

	// Count ToMap methods in both
	methods1 := extractExistingToMapMethods(file1)
	methods2 := extractExistingToMapMethods(file2)

	if len(methods1) != len(methods2) {
		t.Error("File was modified when it should have been skipped")
	}
}

// TestProcessFile_ForceUpdate tests force update flag
func TestProcessFile_ForceUpdate(t *testing.T) {
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "types.go")

	source := `package generated

// Code generated by quicktype. DO NOT EDIT.

type TypeRow struct {
	TypeID int ` + "`json:\"typeID\"`" + `
	NewField string ` + "`json:\"newField\"`" + `
}

func (t *TypeRow) ToMap() map[string]interface{} {
	return map[string]interface{}{"typeID": t.TypeID}
}
`

	err := os.WriteFile(testFile, []byte(source), 0644)
	if err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	// Process with force update
	cfg := &Config{
		InputFiles:  []string{testFile},
		DryRun:      false,
		Verbose:     false,
		ForceUpdate: true,
	}

	err = processFile(testFile, cfg)
	if err != nil {
		t.Fatalf("Failed to process file: %v", err)
	}

	// Read the result
	result, err := os.ReadFile(testFile)
	if err != nil {
		t.Fatalf("Failed to read result: %v", err)
	}

	resultStr := string(result)

	// Should have new field in ToMap (force regenerated)
	if !strings.Contains(resultStr, "newField") {
		t.Error("Force update did not regenerate ToMap with new field")
	}

	// Count occurrences of ToMap - should still be 1 (replaced, not duplicated)
	count := strings.Count(resultStr, "func (t *TypeRow) ToMap()")
	if count > 2 {
		t.Errorf("Expected at most 2 ToMap methods (original might remain), got %d", count)
	}
}

// TestProcessFile_NonGeneratedCode tests safety check for non-generated files
func TestProcessFile_NonGeneratedCode(t *testing.T) {
	tmpDir := t.TempDir()
	testFile := filepath.Join(tmpDir, "custom.go")

	source := `package custom

type CustomType struct {
	ID int
}
`

	err := os.WriteFile(testFile, []byte(source), 0644)
	if err != nil {
		t.Fatalf("Failed to create test file: %v", err)
	}

	originalContent, _ := os.ReadFile(testFile)

	// Process the file
	cfg := &Config{
		InputFiles:  []string{testFile},
		DryRun:      false,
		Verbose:     false,
		ForceUpdate: false,
	}

	err = processFile(testFile, cfg)
	if err != nil {
		t.Fatalf("Failed to process file: %v", err)
	}

	// Read the result
	result, err := os.ReadFile(testFile)
	if err != nil {
		t.Fatalf("Failed to read result: %v", err)
	}

	// File should be unchanged (safety check skipped it)
	if string(originalContent) != string(result) {
		t.Error("Non-generated file was modified")
	}
}

// TestAnalyzeType tests type analysis
func TestAnalyzeType(t *testing.T) {
	tests := []struct {
		name      string
		source    string
		fieldName string
		expected  TypeInfo
	}{
		{
			name: "Simple int",
			source: `package test
type T struct { ID int }`,
			fieldName: "ID",
			expected:  TypeInfo{Name: "int", IsPtr: false, IsMap: false, IsSlice: false, IsStruct: false},
		},
		{
			name: "Pointer to int",
			source: `package test
type T struct { ID *int }`,
			fieldName: "ID",
			expected:  TypeInfo{Name: "*int", IsPtr: true, IsMap: false, IsSlice: false, IsStruct: false},
		},
		{
			name: "Map type",
			source: `package test
type T struct { Data map[string]string }`,
			fieldName: "Data",
			expected:  TypeInfo{Name: "map", IsPtr: false, IsMap: true, IsSlice: false, IsStruct: false},
		},
		{
			name: "Slice type",
			source: `package test
type T struct { Items []string }`,
			fieldName: "Items",
			expected:  TypeInfo{Name: "slice", IsPtr: false, IsMap: false, IsSlice: true, IsStruct: false},
		},
		{
			name: "Custom struct",
			source: `package test
type T struct { Name NameStruct }`,
			fieldName: "Name",
			expected:  TypeInfo{Name: "NameStruct", IsPtr: false, IsMap: false, IsSlice: false, IsStruct: true},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			fset := token.NewFileSet()
			file, err := parser.ParseFile(fset, "test.go", tt.source, 0)
			if err != nil {
				t.Fatalf("Failed to parse source: %v", err)
			}

			// Find the field
			var fieldType ast.Expr
			ast.Inspect(file, func(n ast.Node) bool {
				if field, ok := n.(*ast.Field); ok {
					if len(field.Names) > 0 && field.Names[0].Name == tt.fieldName {
						fieldType = field.Type
						return false
					}
				}
				return true
			})

			if fieldType == nil {
				t.Fatalf("Field %s not found", tt.fieldName)
			}

			result := analyzeType(fieldType)

			if result.Name != tt.expected.Name {
				t.Errorf("Name: expected %q, got %q", tt.expected.Name, result.Name)
			}
			if result.IsPtr != tt.expected.IsPtr {
				t.Errorf("IsPtr: expected %v, got %v", tt.expected.IsPtr, result.IsPtr)
			}
			if result.IsMap != tt.expected.IsMap {
				t.Errorf("IsMap: expected %v, got %v", tt.expected.IsMap, result.IsMap)
			}
			if result.IsSlice != tt.expected.IsSlice {
				t.Errorf("IsSlice: expected %v, got %v", tt.expected.IsSlice, result.IsSlice)
			}
			if result.IsStruct != tt.expected.IsStruct {
				t.Errorf("IsStruct: expected %v, got %v", tt.expected.IsStruct, result.IsStruct)
			}
		})
	}
}
